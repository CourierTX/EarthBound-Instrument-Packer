namespace EBInstPack
{
    class PreviewSPC
    {
        //Thank you cooprocks123e and KungFuFurby for the advice!
        public byte[] filedata;
        private const int spcHeaderSize = 0x0100;

        public PreviewSPC(Config config, byte[] sampleDirectory, byte[] brrDump, EBMFile song)
        {
            var result = FileIO.GetDummySPC();
            //TODO: Make a class that runs GetDummySPC and has a .PatchData(byte[] , offset) method *in* it

            //Make the sound engine think that the new song is being loaded, so it'll reset all the patterns
            result = PatchData(result, Padding(0x00, 1), 0x08);

            //Make it so this SPC's song index (song 0x53) knows to look for the note data at whatever offset it needs to be in
            result = PatchData(result, HexHelpers.UInt16toByteArray_LittleEndian(song.aramOffset), 0x2EEE);

            //Zero out a few locations to make sure there aren't garbage notes playing in any of the channels
            var padding = Padding(0x00, 2);
            for (uint offset = 0x010000; offset <= 0x010070; offset += 0x10)
            {
                result = PatchData(result, padding, offset);
            }

            //Patch in all of the data generated by this program, as well as the song data
            result = PatchData(result, sampleDirectory, config.offsetForSampleDir);
            result = PatchData(result, brrDump, config.offsetForBRRdump);
            result = PatchData(result, config.GetPatches(), config.offsetForInstrumentConfig);
            result = PatchData(result, song.data, song.aramOffset);

            filedata = result;
        }

        private static byte[] PatchData(byte[] fileToPatch, byte[] data, uint aramOffset)
        {
            data.CopyTo(fileToPatch, spcHeaderSize + aramOffset);
            return fileToPatch;
        }

        private static byte[] Padding(byte value, int count)
        {
            var result = new byte[count];
            for (int i = 0; i < result.Length; i++)
            {
                result[i] = value; //make a byte array of any size, full of the same number
            }
            return result;
        }
    }
}
